/* 
 * noun.c -- Nouns are like "mobs", but with a classier name.
 *
 * Copyright (C) 2012 Jason Linehan 
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software Foundation, 
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */
#include <assert.h>
#include "../com/barnacle.h"
#include "../lib/matrix.h"
#include "../lib/stoc/stoc.h"
#include "../lib/textutils.h"
#include "../lib/hash/hash.h"
#include "../item/item.h"
#include "../lib/fsm/fsm.h"
#include "../gfx/ui/menu_inventory.h"
#include "../gfx/ui/notify.h"
#include "noun.h"
#include "models/hopper.h"
#include "models/omega.h"


struct noun_t *PLAYER;


/* NOUN STORAGE ***************************************************************
 *
 * Three distinct structures handle the various aspects of noun bookkeeping. 
 * The master structure is a hashtable referred to simply as the "nountable"
 * in most of this documentation. Every noun is identified by a key value,
 * generated by hashing the 'name' member of the noun object, and this is
 * used to access pointers to the nouns in the nountable. 
 *
 * The other two structures are circular doubly linked lists / rings.
 * One of these stores the keys (hashed names) of every active noun, and
 * is called 'keyring'. The other stores the keys of every noun which has
 * called its 'doom' method, but has not yet been destroyed. 
 *
 ******************************************************************************/

struct noun_key { struct list_node node; uint32_t key; };

/**                                                 
 * KEY RING                                         
 * Each node of 'keyring' has type struct noun_key (see above) 
 */
LIST_HEAD(keyring);

/**
 * DOOM RING
 * Nouns scheduled for deletion will be culled at the beginning of each
 * tick, before any processing on them would be done. See the doom() function.
 */
LIST_HEAD(doomring);

/**
 * NOUNTABLE 
 * Accessor functions should be used to interact with the nountable,
 * to prevent "orphan" keys on the keyring.
 */
struct htab_t *nountable;



/* NOUN STORAGE FUNCTIONS *****************************************************/

/**
 * CHECK 
 * check_nountable -- ensure the hashtable is initialized and allocated */ 
inline void check_nountable(void)
{
        if (!nountable) { 
                nountable = new_htab(0);
        }
        assert(nountable || "Could not allocate noun table");
}

/**
 * HASH
 * hash -- the hash function for noun name strings */
static inline uint32_t hash(const char *name)
{
        return (fasthash(name, strlen(name)));
}

/**
 * STORE
 * add_to_nountable -- insert a noun into the noun hash table and refcount */
void add_to_nountable(struct noun_t *noun)
{
        struct noun_key *new = calloc(1, sizeof(struct noun_key));

        new->key = noun->id;
        list_add(&keyring, &new->node);

        htab_add(nountable, noun->id, noun); 
}

/**
 * DELETE 
 * del_from_nountable -- remove a noun from the noun hash table and refcount */
void del_from_nountable(struct noun_t *noun)
{
        struct noun_key *tmp, *nxt;

        if (list_empty(&keyring))
                return;

        list_for_each_safe(&keyring, tmp, nxt, node) {
                if (tmp->key == noun->id) {
                        list_del_from(&keyring, &tmp->node);
                }
        }

        htab_pop(nountable, noun->id); 
}

/**
 * FREE DOOMED NOUNS
 * free_nouns -- frees all the nouns on the doomring
 */
void free_nouns(void)
{
        struct noun_key *tmp, *nxt;
        struct noun_t *noun;

        if (list_empty(&doomring))
                return;

        list_for_each_safe(&doomring, tmp, nxt, node) {
                list_del_from(&doomring, &tmp->node);
                noun = key_noun(tmp->key);
                noun->del(noun);
        }
}

/**
 * UPDATE ALL NOUNS
 * Calls the update method of each active noun
 */
void update_nouns(void)
{
        struct noun_key *tmp;
        struct noun_t *noun;

        if (list_empty(&keyring))
                return;

        list_for_each(&keyring, tmp, node) {
                noun = key_noun(tmp->key);
                if (noun != NULL) {
                        noun->modify(noun);
                        noun->render(noun);
                }
        }
}



/* NOUN CONSTRUCTORS **********************************************************/

/**
 * NOUN METHOD REFERENCES
 * The method functions must be forward-referenced so that they are visible
 * in the scope of the new_noun() function. Their implementation occurs
 * further down in the file.
 */
void method_noun_step(void *self, int dir);
void method_noun_setyx(void *self, int y, int x);
void method_noun_hit(void *self);
void method_noun_fall(void *self);
void method_noun_seek(void *self, void *target);
void method_noun_mobile(void *self, bool opt);
void method_noun_delete(void *self);
void method_noun_animate(void *self, void *animation);
void method_noun_doom(void *self);
void method_noun_update(void *self);
void method_noun_player(void *self, bool opt);
void method_noun_eatitem(void *self);
void method_noun_takeitem(void *self);

bool route_to_noun(void *self); /* for the FSM (see lib/fsm.c) */


/**
 * new_noun -- Create a new noun object and store it in the nountree
 * @name : the name of the noun
 * @model: the type enum of the noun
 * @obj  : the class struct containing type-specific data
 */
struct noun_t *new_noun(const char *name, uint32_t model)
{
        check_nountable();

        struct noun_t *new = calloc(1, sizeof(struct noun_t));

        if (name == NULL) {
                switch (model) {
                case HOPPER:
                        spawn_hopper(new);
                        break;
                case OMEGA:
                        /*spawn_omega(new);*/
                        break;
                }
        }
        else
                new->name  = cdup(name);

        new->id    = hash(new->name);
        new->model = model;

        /* Member objects */
        new->sm    = new_sm(new->id, &route_to_noun);
        new->astar = new_astar();
        list_head_init(&new->inv);

        /* Boolean state */
        new->is_mobile   = false;
        new->hit_testing = true;

        /* Static methods */
        new->step     = &method_noun_step;
        new->hit      = &method_noun_hit;
        new->fall     = &method_noun_fall;
        new->seek     = &method_noun_seek;
        new->setyx    = &method_noun_setyx;
        new->mobile   = &method_noun_mobile;
        new->animate  = &method_noun_animate;
        new->del      = &method_noun_delete;
        new->doom     = &method_noun_doom;
        new->update   = &method_noun_update;
        new->player   = &method_noun_player;
        new->eat      = &method_noun_eatitem;
        new->pickup   = &method_noun_takeitem;

        /* Apply dynamic linkage */
        apply_noun_model(new);

        /* Store the noun */
        add_to_nountable(new);

        return new;
}


/**
 * spawn_noun -- Create a new noun object and provide options to generate it
 * @name  : the name of the noun
 * @model : the type enum of the noun
 * @mobile: is the noun mobile or not
 * @y     : y-coordinate where to place it
 * @x     : x-coordinate where to place it
 */
void spawn_noun(uint32_t model, int y, int x, bool mobile)
{
        struct noun_t *noun = new_noun(NULL, model); 

        assert((noun && noun->name)  || !"Noun corrupt on spawn\n");
        assert((get_noun(noun->name))|| !"Noun missing from nountable\n");

        noun->mobile(noun, mobile);
        noun->setyx(noun, y, x);
}




/* NOUN RETREIVAL *************************************************************/

/**
 * DO NOT FOCUS 
 * find_noun -- return a noun without setting 'focused'
 * @id: unsigned 32-bit unique id
 */
struct noun_t *find_noun(uint32_t id)
{
        return (struct noun_t *)htab_get(nountable, id);
}

/**
 * BY ID (KEY)
 * key_noun -- return a noun given its id number 
 * @id: unsigned 32-bit unique id
 */
struct noun_t *key_noun(uint32_t id)
{
        focused = htab_get(nountable, id);
        return (focused);
}

/**
 * BY VALUE (STRING)
 * get_noun -- return a noun given it's name string 
 * @name: name of the noun to be returned
 */
struct noun_t *get_noun(const char *name)
{
        uint32_t key = fasthash(name, strlen(name));

        return (htab_exists(nountable, key)) ? key_noun(key) : NULL;
}

/**
 * BY COORDINATES (Y,X)
 * get_noun_at -- given coordinates y, x, return any noun at that position
 * @y: y-coordinate
 * @x: x-coordinate
 */
struct noun_t *get_noun_at(struct map_t *map, int y, int x)
{
        return (key_noun(mx_val(map->mobs, y, x)));  
}

/**
 * NOUN MODEL 
 * noun_model -- return the model of the noun given an id number
 * @id: noun identifier 
 */
int noun_model(uint32_t id)
{
        struct noun_t *noun;
        noun = find_noun(id);
        return noun ? noun->model : NOMODEL;
}


struct noun_t *get_player(void)
{
        return PLAYER;
}



/* NOUN METHODS ***************************************************************
 *
 * A noun object contains methods, all of which expect a void *self argument 
 * unambiguously references the caller (the noun object). 
 *
 ******************************************************************************/

/**
 * PRIVATE METHOD HELPER
 * noun_mark_position -- update the position of the noun id on the map matrix */
inline void noun_mark_position(struct noun_t *noun)
{
        mx_set(ACTIVE->mobs, pos_saved_y(noun->pos), pos_saved_x(noun->pos), 0);
        mx_set(ACTIVE->mobs, pos_y(noun->pos), pos_x(noun->pos), noun->id);
}

/**
 * PRIVATE METHOD HELPER
 * hit_detected -- test whether a terrain collision is occuring */
inline bool hit_detected(struct noun_t *noun)
{
        return (map_hit(ACTIVE, noun) || mob_hit(ACTIVE, noun)) ? true : false;
}

/**
 * PRIVATE METHOD HELPER
 * noun_on_move -- called every time a noun's position is changed */
void noun_on_move(struct noun_t *noun)
{
        noun->hit(noun);
        noun_mark_position(noun);

        move_panel(noun->pan, pos_y(noun->pos), pos_x(noun->pos));
        astar_set_start(noun->astar, pos_y(noun->pos), pos_x(noun->pos));
        take_bkgrnd(noun->win, PEEK(ACTIVE->W), FLEX);

        update_panels();

        if (DOOR(ACTIVE, pos_y(noun->pos), pos_x(noun->pos)))
                door_trigger(noun, DOOR(ACTIVE, pos_y(noun->pos), pos_x(noun->pos)));
}

/* METHODS ********************************************************************/

/**
 * DEL METHOD
 * method_noun_delete -- delete a noun object
 * @self: the noun object
 */
void method_noun_delete(void *self)
{
        struct noun_t *noun = NOUN(self);

        del_panel(noun->pan);
        delwin(noun->win);

        del_sm(noun->sm);
        free(noun->sm);

        del_astar(noun->astar);
        free(noun->astar);

        mx_set(ACTIVE->mobs, pos_y(noun->pos), pos_x(noun->pos), 0UL);
        noun->pos->del(noun->pos);

        /* Remove from the nountable */
        del_from_nountable(noun);

        /* Goodbye */
        /*free(noun);*/
}

/**
 * UPDATE METHOD
 * method_noun_update -- modify and then render a noun object
 * @self: the noun object
 */
void method_noun_update(void *self)
{
        struct noun_t *noun = NOUN(self);

        noun->modify(noun);
        noun->render(noun);
}


/**
 * MOBILE METHOD
 * method_noun_mobile -- set a noun to the active state
 * @self: the noun object
 */
void method_noun_mobile(void *self, bool opt)
{
        struct noun_t *noun = NOUN(self);
        noun->is_mobile = opt;
}


void method_noun_player(void *self, bool opt)
{
        struct noun_t *noun = NOUN(self);
        PLAYER = (opt) ? noun : NULL;
}



/**
 * HIT METHOD
 * method_noun_hit -- perform the collision test
 * @self: the noun object
 */
void method_noun_hit(void *self)
{
        struct noun_t *noun = NOUN(self);

        if (noun->hit_testing && hit_detected(noun))
                noun->pos->restore(noun->pos);
}


/**
 * SETYX METHOD
 * method_noun_setyx -- reposition the noun to coordinates y,x 
 * @self: the noun object
 * @y: y-coordinate to position noun at
 * @x: x-coordinate to position noun at
 */
void method_noun_setyx(void *self, int y, int x)
{
        struct noun_t *noun = NOUN(self);

        noun->pos->setyx(noun->pos, y, x);
        noun_on_move(noun);
}


/**
 * STEP METHOD
 * method_noun_step -- move the noun in a given direction 
 * @self: the noun object
 * @dir: direction
 */
void method_noun_step(void *self, int dir)
{
        #define UR 231
        #define UL 225
        #define DR 214
        #define DL 208

        struct noun_t *noun = NOUN(self);

        switch (dir) {
        case 'u':       
                pos_u(noun->pos);
                break;
        case 'd':       
                pos_d(noun->pos);
                break;
        case 'l':       
                pos_l(noun->pos);
                break;
        case 'r':      
                pos_r(noun->pos);
                break;
        case UR:
                pos_u(noun->pos);
                pos_r(noun->pos);
                break;
        case UL:
                pos_u(noun->pos);
                pos_l(noun->pos);
                break;
        case DR:
                pos_d(noun->pos);
                pos_r(noun->pos);
                break;
        case DL:
                pos_d(noun->pos);
                pos_l(noun->pos);
                break;
        }
        noun_on_move(noun);
}


/**
 * FALL METHOD
 * method_noun_fall -- shift a noun's position downward if gravity is enabled
 * @self: the noun object
 */
void method_noun_fall(void *self)
{
        struct noun_t *noun = NOUN(self);
        int y;
        int x;

        if (!gravity_enabled)
                return;

        y = pos_y(noun->pos);
        x = pos_x(noun->pos);

        if (TILE(ACTIVE, y, x) == ROPE)
                return;

        inc(y, pos_ymax(noun->pos));

        if (TILE(ACTIVE, y, x) == CAVEFLOOR)
                noun->step(noun, 'd');
}


/**
 * SEEK METHOD
 * method_noun_seek -- run the A* function to seek a target noun
 * @self: the noun object
 * @target: the noun object to seek
 */
void method_noun_seek(void *self, void *target)
{
        struct noun_t *s = NOUN(self);
        struct noun_t *g = NOUN(target);

        if ((s->astar->current == NULL) 
        || !(same_cell(s->astar->current, g->astar->start))) 
        {
                if (!a_star(s->astar, g->astar->start))
                        return;
        }
        struct cell_t *tmp;
        tmp = cellpath_next(&s->astar->path);

        /* Sometimes there -is- no next */
        if (tmp) {
                if (tmp->x > s->astar->start->x)
                        sm_msg(s->sm, SM_SELF, SM_GoRight);
                if (tmp->x < s->astar->start->x)
                        sm_msg(s->sm, SM_SELF, SM_GoLeft);
                if (tmp->y > s->astar->start->y)
                        sm_msg(s->sm, SM_SELF, SM_GoDown);
                if (tmp->y < s->astar->start->y)
                        sm_msg(s->sm, SM_SELF, SM_GoUp);
        }
}


/**
 * ANIMATE METHOD
 * method_noun_animate -- set the current animation
 * @self: the noun object
 * @animation: the new animation pointer
 */
void method_noun_animate(void *self, void *animation)
{
        struct noun_t *noun = NOUN(self);
        noun->animation = (struct ani_t *)animation;
        /*
         * Initialize animation length if it hasn't been set (lets us
         * declare inline struct ani_t's in model files)
         */
        if (noun->animation->len == 0)
                noun->animation->len = wcslen(noun->animation->wcs);

        wbkgrnd(noun->win, mkcch(noun->sprite, 0, noun->color));
}


/**
 * DOOM METHOD
 * method_noun_doom -- doom the current noun to deletion
 * @self: the noun object
 */
void method_noun_doom(void *self)
{
        struct noun_t *noun = NOUN(self);
        struct noun_key *new; 

        new = calloc(1, sizeof(struct noun_key));

        new->key = noun->id;

        list_add(&doomring, &new->node);
}



/**
 * PRIVATE
 * route_to_noun -- the routing method for the state machine configuration */
bool route_to_noun(void *self)
{
        struct msg_t *msg = (struct msg_t *)self;
        struct noun_t *noun;
        bool status;

        noun = key_noun(msg_to(msg));

        if (noun != NULL) {
                assert((noun && msg) || !"Message router is boned!");
                status = sm_accept(noun->sm, msg);
                return (status) ? SM_ROUTE_OK : SM_NO_ROUTE; 
        }
        return SM_NO_ROUTE;
}



void noun_set_signal_delayed(struct noun_t *noun, uint32_t state, int dir)
{
        int y = pos_y(noun->pos);
        int x = pos_x(noun->pos);
        
        switch (dir) {
        case 'u':
                dec(y, pos_ymin(noun->pos));
                break;
        case 'd':
                inc(y, pos_ymax(noun->pos));
                break;
        case 'l':
                dec(x, pos_xmin(noun->pos));
                break;
        case 'r':
                inc(x, pos_xmax(noun->pos));
                break;
        default:
                break; /* Signal will be sent to the sender */
        }
        sm_msg(noun->sm, mx_val(ACTIVE->mobs, y, x), state);
}

void noun_set_signal(struct noun_t *noun, uint32_t state, int dir)
{
        noun_set_signal_delayed(noun, state, dir);
}


void emit_to_noun(struct noun_t *noun, int dir, uint32_t state)
{
        int y = pos_y(noun->pos);
        int x = pos_x(noun->pos);
        
        switch (dir) {
        case 'u':
                dec(y, pos_ymin(noun->pos));
                break;
        case 'd':
                inc(y, pos_ymax(noun->pos));
                break;
        case 'l':
                dec(x, pos_xmin(noun->pos));
                break;
        case 'r':
                inc(x, pos_xmax(noun->pos));
                break;
        default:
                break; /* Signal will be sent to the sender */
        }
        sm_msg(noun->sm, mx_val(ACTIVE->mobs, y, x), state);
}



/**
 * TAKE ITEM
 * method_noun_takeitem -- move an item from the map at (y,x) to noun inventory 
 * @self: pointer to noun object
 * @y   : y-coordinate of item on map
 * @x   : x-coordinate of item on map
 */
void method_noun_takeitem(void *self)
{
        struct noun_t *noun = (struct noun_t *)self;
        struct item_t *item;

        item = yx_item(ACTIVE, pos_y(noun->pos), pos_x(noun->pos));

        if (!item)
                return;

        inventory_add(&noun->inv, item);
        inventory_to_menu(&noun->inv);
        alert(I_FIND, item->name);
}

/**
 * EAT ITEM
 * method_noun_eatitem -- use the equipped item, then destroy it
 * @self: pointer to noun object
 */
void method_noun_eatitem(void *self)
{
        struct noun_t *noun = (struct noun_t *)self;
        struct item_t *item;

        if (item = equipped, !item)
                return;

        inventory_del(&noun->inv, item);
        inventory_to_menu(&noun->inv);        
}


