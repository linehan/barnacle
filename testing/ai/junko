
        if (current->x > 0) {
                struct cell_t *n0 = new_cell(current->y, current->x-1);
                if (bh_member_of(CLOSED, zcode(n0))) {
                        free(n0);
                        break;
                } else {
                        temp_g_score = current->g + mov_cost(current, n0);
                        if (!bh_member_of(OPEN, zcode(n0))) {
                                bh_add(OPEN, zcode(n0), 0, n0);
                                n0->h = h_cost(astar, n0);
                        } else if (temp_g_score < g_cost(astar, n0)) {
                                temp_is_better = true;
                        } else {
                                temp_is_better = false;
                        }
                        if (temp_is_better) {
                                n0->parent = current;
                                n0->g = temp_g_score;
                                n0->f = n0->g + n0->h;
                                heapify(OPEN);
                        } else {
                                /*free(n0);*/
                        }
                }
        }

        if (current->y > 0) {
                struct cell_t *n1 = new_cell(current->y-1, current->x);
                if (bh_member_of(CLOSED, zcode(n1))) {
                        free(n1);
                        break;
                } else {
                        temp_g_score = current->g + mov_cost(current, n1);
                        if (!bh_member_of(OPEN, zcode(n1))) {
                                bh_add(OPEN, zcode(n1), 0, n1);
                                n1->h = h_cost(astar, n1);
                        } else if (temp_g_score < g_cost(astar, n1)) {
                                temp_is_better = true;
                        } else {
                                temp_is_better = false;
                        }
                        if (temp_is_better) {
                                n1->parent = current;
                                n1->g = temp_g_score;
                                n1->f = n1->g + n1->h;
                                heapify(OPEN);
                        } else {
                                /*free(n1);*/
                        }
                }
        }

        if (current->x < astar->cols) {
                struct cell_t *n2 = new_cell(current->y, current->x+1);
                uint32_t zn2 = zcode(n2);
                if (bh_member_of(CLOSED, zn2)) {
                        free(n2);
                        break;
                } else {
                        temp_g_score = current->g + mov_cost(current, n2);
                        if (!bh_member_of(OPEN, zn2)) {
                                bh_add(OPEN, zcode(n2), 0, n2);
                                n2->h = h_cost(astar, n2);
                        } else if (temp_g_score < g_cost(astar, n2)) {
                                temp_is_better = true;
                        } else {
                                temp_is_better = false;
                        }
                        if (temp_is_better) {
                                n2->parent = current;
                                n2->g = temp_g_score;
                                n2->f = n2->g + n2->h;
                                heapify(OPEN);
                        } else {
                                /*free(n2);*/
                        }
                }
        }

        if (current->y < astar->rows) {
                struct cell_t *n3 = new_cell(current->y+1, current->x);
                if (bh_member_of(CLOSED, zcode(n3))) {
                        /*free(n3);*/
                } else {
                        temp_g_score = current->g + mov_cost(current, n3);
                        if (!bh_member_of(OPEN, zcode(n3))) {
                                bh_add(OPEN, zcode(n3), 0, n3);
                                n3->h = h_cost(astar, n3);
                        } else if (temp_g_score < g_cost(astar, n3)) {
                                temp_is_better = true;
                        } else {
                                temp_is_better = false;
                        }
                        if (temp_is_better) {
                                n3->parent = current;
                                n3->g = temp_g_score;
                                n3->f = n3->g + n3->h;
                                heapify(OPEN);
                        } else {
                                /*free(n3);*/
                        }
                }
        }

